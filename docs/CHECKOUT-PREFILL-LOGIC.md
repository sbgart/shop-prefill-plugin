# Логика предзаполнения checkout параметров

## Источник данных для предзаполнения

Плагин берет данные **напрямую из БД**:

### Для авторизованных пользователей

```
contact_id → SELECT последний заказ из shop_order → параметры из shop_order_params
```

### Для неавторизованных (гостей)

```
cookie prefill_guest_hash → SELECT заказ по хешу из shop_order_params → параметры заказа
```

**Преимущества:**
- Всегда актуальные данные (менеджер исправил заказ → изменения применяются)
- Для гостей — все заказы привязаны к одному хешу

---

## Основные сценарии использования

### 1. Единый метод предзаполнения (preFillCheckoutParams)

Метод `preFillCheckoutParams()` используется в обоих хуках с одинаковой логикой проверки наличия данных.

#### 1.1. Предзаполнение при входе на сайт (frontendHead hook)

- **Когда:** При входе на любую страницу магазина
- **Условие:** Включена настройка `on_entry`
- **Частота:** 1 раз за HTTP-запрос (флаг `$this->prefilled`)

#### 1.2. Предзаполнение на странице чекаута (frontendOrder hook)

- **Когда:** При заходе на страницу оформления заказа
- **Условие:** Всегда при активном плагине
- **Частота:** Каждый раз при загрузке страницы чекаута
- **Особенность:** Если метод уже вызывался в этом запросе (`frontendHead`), то повторного вызова метода не будет так как `$this->prefilled = true`

#### Общее поведение метода:

- ✅ Проверяет наличие данных в `checkout_params` ПЕРЕД заполнением секций
- ✅ Заполняет только секции, где нет данных (проверка по ключевым полям: `email`, `city`, `type_id`) - это пока под большим сомнением, сама логика такой проверки.
- ✅ Использует `deepMergeArrays` для слияния данных
- ✅ Не перезаписывает данные, введенные пользователем

---

## Секция AUTH (авторизация)

**Важно:** Секцию `auth` нельзя отключить через настройки Shop-Script — это обязательная часть процесса checkout. Настройка `prefill_disabled['section']['auth']` в плагине prefill только отключает предзаполнение этой секции плагином, но не скрывает саму секцию в checkout.

### Когда НЕ предзаполняем:

1. ✅ **Пользователь авторизован** → Webasyst автоматически берет данные из контакта
2. ✅ **Предзаполнение секции отключено в настройках плагина** → `prefill_disabled['section']['auth']` (доступно в настройках витрины плагина)
3. ✅ **Отдельные поля отключены** → `prefill_disabled['fields']['email']`
4. ❓ **В полях уже есть данные** → текущая реализация проверяет только `email`

### Что заполняется:

- `order['auth']['mode']` — тип покупателя (person/company)
- `order['auth']['data']['email']` — email
- `order['auth']['data']['phone']` — телефон
- `order['auth']['data']['firstname']` — имя
- `order['auth']['data']['lastname']` — фамилия
- `order['auth']['data']['middlename']` — отчество
- `order['auth']['data']['name']` — полное имя
- `order['auth']['data']['company']` — компания
- `order['auth']['data'][{custom_field}]` — кастомные поля контакта

### Проблемы:

1. ❌ **Неточная проверка:** Проверяется только `email`, другие поля (`phone`, `firstname`, `lastname`) могут быть затерты
   - **Сценарий:** Пользователь ввел телефон и имя, но не email → плагин перезапишет всё
2. ✅ **Единый метод с проверками** → заполняет только пустые секции во всех случаях

---

## Секция REGION (адрес доставки)

### Когда НЕ предзаполняем:

1. ✅ **Секция отключена в настройках** → `prefill_disabled['section']['region']` (доступно в настройках витрины)
2. ❓ **В полях уже есть данные** → текущая реализация проверяет только `city`

### Текущая реализация проверки (preFillCheckoutParams):

```php
if (! isset($checkout_params['order']['region']['city'])) {
    $this->prepareRegionSectionParams($params, $final_params);
}
```

### Что заполняется:

- `order['region']['country']` — код страны
- `order['region']['region']` — код региона
- `order['region']['city']` — название города
- `order['region']['zip']` — почтовый индекс

### Проблемы:

1. ❌ **Неточная проверка:** Проверяется только `city`, другие поля (`country`, `region`, `zip`) могут быть затерты
   - **Сценарий:** Пользователь ввел только индекс → плагин перезапишет всё
2. ✅ **Единый метод с проверками** → заполняет только пустые секции

---

## Секция SHIPPING (доставка)

### Когда НЕ предзаполняем:

1. ⚠️ **Секция отключена в настройках** → `prefill_disabled['section']['shipping']` (проверка есть в коде, но настройка отсутствует в интерфейсе)
2. ❓ **В полях уже есть данные** → текущая реализация проверяет только `type_id`

### Текущая реализация проверки (preFillCheckoutParams):

```php
if (! isset($checkout_params['order']['shipping']['type_id'])) {
    $this->prepareShippingSectionParams($params, $final_params);
    $this->preparePaymentSectionParams($params, $final_params);  // ⚠️ Зависимость!
    $this->prepareConfirmSectionParams($params, $final_params);   // ⚠️ Зависимость!
}
```

### Что заполняется:

- `order['shipping']['type_id']` — ID способа доставки
- `order['shipping']['variant_id']` — ID варианта доставки
- `order['details']['custom'][{param}]` — кастомные параметры доставки (из плагина доставки)

### Проблемы:

1. ❌ **Payment и Confirm зависят от проверки shipping** → если пользователь написал комментарий, но не выбрал доставку, комментарий будет затерт
2. ✅ **Единый метод с проверками** → заполняет только пустые секции

---

## Секция PAYMENT (оплата)

### Когда НЕ предзаполняем:

1. ⚠️ **Секция отключена в настройках** → `prefill_disabled['section']['payment']` (проверка есть в коде, но настройка отсутствует в интерфейсе)
2. ❌ **Собственной проверки НЕТ** → зависит от проверки shipping.type_id

### Текущая реализация проверки (preFillCheckoutParams):

```php
// Проверки НЕТ! Вызывается только если shipping не заполнен
```

### Что заполняется:

- `order['payment']['id']` — ID способа оплаты
- `order['payment']['custom'][{param}]` — кастомные параметры оплаты

### Проблемы:

1. ❌ **Нет независимой проверки заполненности** → зависит от shipping
   - **Сценарий:** Пользователь выбрал способ оплаты, но не выбрал доставку → оплата будет перезаписана
2. ✅ **Единый метод с проверками** → заполняет только пустые секции (но payment все равно зависит от shipping)

---

## Секция CONFIRM (комментарий к заказу)

### Когда НЕ предзаполняем:

1. ✅ **Поле отключено в настройках** → `prefill_disabled['fields']['comment']` (доступно в настройках витрины)
2. ⚠️ **Секция отключена в настройках** → `prefill_disabled['section']['confirm']` (проверка есть в коде, но настройка отсутствует в интерфейсе)
3. ❌ **Собственной проверки НЕТ** → зависит от проверки shipping.type_id

### Текущая реализация проверки (preFillCheckoutParams):

```php
// Проверки НЕТ! Вызывается только если shipping не заполнен
```

### Что заполняется:

- `order['confirm']['comment']` — комментарий пользователя к заказу

### Проблемы:

1. ❌ **Нет независимой проверки заполненности** → зависит от shipping
   - **Сценарий:** Пользователь написал комментарий, но не выбрал доставку → комментарий будет затерт
2. ✅ **Единый метод с проверками** → заполняет только пустые секции (но confirm все равно зависит от shipping)

---

## Механизм блокировки повторного заполнения

### Флаг `$this->prefilled`

**Где используется:** Только в `preFillCheckoutParams()`

**Логика:**

```php
if ($this->prefilled) {
    return; // Уже заполняли — выходим
}
// ... заполнение ...
$this->prefilled = true;
```

**Жизненный цикл:**

- Устанавливается в `true` после первого вызова `preFillCheckoutParams()`
- Хранится в экземпляре класса (singleton в рамках HTTP-запроса)
- Сбрасывается при новом HTTP-запросе (новый экземпляр класса)

**Когда НЕ сбрасывается (но возможно должен?):**

1. ❓ Смена витрины
2. ❓ Logout/login пользователя
3. ❓ Очистка корзины
4. ❓ Изменение параметров заполнения в админке

---

## Использование метода preFillCheckoutParams

| Параметр                      | frontendHead (при входе)           | frontendOrder (на чекауте)          |
| ----------------------------- | ---------------------------------- | ----------------------------------- |
| **Когда вызывается**          | На любой странице магазина (1 раз) | На странице чекаута (каждый раз)    |
| **Проверка заполненности**    | ✅ Есть (проверка перед вызовом)   | ✅ Есть (проверка перед вызовом)    |
| **Флаг prefilled**            | ✅ Используется для оптимизации    | ✅ Учитывается (если уже вызывался) |
| **Поведение**                 | Мягкое (только пустые секции)      | Мягкое (только пустые секции)       |
| **Риск перезаписи**           | ✅ Низкий                          | ✅ Низкий                           |
| **Проверки внутри prepare\*** | ✅ Есть (prefill_disabled, auth)   | ✅ Есть (prefill_disabled, auth)    |

---

## Ключевые вопросы для анализа

### 1. Как определить "секция уже заполнена"?

**Текущий подход:** Проверяется одно ключевое поле

- Auth → `email`
- Region → `city`
- Shipping → `type_id`
- Payment → нет проверки
- Confirm → нет проверки

**Варианты улучшения:**

#### Вариант A: Проверять все поля секции

```php
$auth_fields = ['email', 'phone', 'firstname', 'lastname'];
$auth_filled = false;
foreach ($auth_fields as $field) {
    if (!empty($checkout_params['order']['auth']['data'][$field])) {
        $auth_filled = true;
        break;
    }
}
```

✅ Точно  
❌ Сложнее, нужен список всех полей

#### Вариант B: Проверять несколько ключевых полей

```php
$key_fields = ['email', 'phone'];
$auth_filled = isset($checkout_params['order']['auth']['data']['email'])
            || isset($checkout_params['order']['auth']['data']['phone']);
```

✅ Компромисс между точностью и простотой  
⚠️ Нужно выбрать правильные ключевые поля

#### Вариант C: Собственный флаг в сессии

```php
$checkout_params['_prefilled']['auth'] = true;
```

✅ Явный контроль  
❌ Сложнее синхронизация, нужно сбрасывать при изменениях

### 2. Зачем нужен вызов на странице чекаута (frontendOrder)?

**Сценарии использования:**

1. ✅ Предзаполнение для пользователей, которые попали на страницу чекаута напрямую (минуя `frontendHead`)
2. ✅ Обновление параметров, если пользователь очистил данные или изменились настройки
3. ✅ Гарантия предзаполнения на странице чекаута независимо от того, был ли вызван `preFillCheckoutParams` в `frontendHead`

**Важно:** Метод `preFillCheckoutParams()` всегда проверяет наличие данных перед заполнением. Флаг `prefilled` используется только для оптимизации - если метод уже вызывался в этом HTTP-запросе и все данные заполнены, повторный вызов не выполняется.

### 3. Когда сбрасывать флаг prefilled?

**Сейчас:** Никогда (в рамках одного HTTP-запроса)

**Возможно нужно сбрасывать при:**

- Смене витрины (разные настройки prefill)
- Logout/login (смена пользователя)
- Очистке корзины (начать заново)
- Ручной очистке полей пользователем?

---

## Рекомендации по улучшению

### Краткосрочные (быстрые фиксы):

1. **Разделить проверки для каждой секции**

   ```php
   if (!isset($checkout_params['order']['shipping']['type_id'])) {
       $this->prepareShippingSectionParams(...);
   }

   if (!isset($checkout_params['order']['payment']['id'])) {
       $this->preparePaymentSectionParams(...);
   }

   if (!isset($checkout_params['order']['confirm']['comment'])) {
       $this->prepareConfirmSectionParams(...);
   }
   ```

2. ✅ **Унифицировать методы** — использовать единый метод `preFillCheckoutParams()` с проверками в обоих хуках (выполнено)

3. **Проверять несколько ключевых полей** вместо одного:
   - Auth: `email` ИЛИ `phone`
   - Region: `city` ИЛИ `country`

### Долгосрочные (архитектурные):

1. **Создать явный механизм определения "заполненности секции"**

   - Метод `isSectionFilled(string $section): bool`
   - Гибкая настройка проверяемых полей

2. **Добавить события/хуки** для сброса флага prefilled:

   - При смене витрины
   - При logout/login
   - При очистке корзины

3. **Логирование конфликтов** (опционально, для отладки):
   - Когда плагин пытается перезаписать существующие данные
   - Помогает понять реальное поведение на проде

---

## Выводы

**Главная проблема:** Грубые проверки заполненности приводят к потере данных пользователя.

**Критические места:**

1. Проверка только `email` в auth → затирает `phone`, `firstname`, `lastname`
2. Связка shipping → payment → confirm → затирает независимые секции
3. ✅ **Унифицированы методы** → единый метод `preFillCheckoutParams()` с проверками используется в обоих хуках

**Следующие шаги:**

1. ✅ Унифицировать методы предзаполнения (выполнено)
2. Выбрать стратегию определения "секция заполнена" (улучшить проверки)
3. Реализовать независимые проверки для каждой секции (payment, confirm не зависят от shipping)
4. Добавить механизм сброса флага `prefilled` при необходимости
